# readme

### 目录
* [第9次作业新增内容（最新）](#new2)
  * [bug修改说明](#bug修改说明)
  * [设计文档](#设计文档)
  * [道路交叉方式的输入](#道路交叉方式的输入)
* [新增内容（第8次作业）](#new)
  * [新增测试接口](#新增测试接口)
  * [过程规格](#过程规格)
* [上次内容（第7次作业）](#last)
  * [输入](#输入)
  * [本程序提供的测试接口](#本程序提供的测试接口)
  * [测试](#测试)

---
> <h3 id="new2">第9次作业新增内容（最新）</h3>
> 请***务必***先按顺序阅读[第7次内容（点击跳转）](#last)和[第8次内容（点击跳转）](#new)再阅读[本次内容](#new2)

<h3 id="bug修改说明">bug修改说明</h3>

上次作业，使用了javafx.util.Pair，我用的idea，没有问题，但那哥们用的eclipse说编译不了，其实把jre移除再重新添加就好了，但还是被他扣了一波，我也懒得向课代表申诉了，这次把所有用到的Pair都移除了

<h3 id="设计文档">设计文档</h3>

* 详见设计文档
* 包含以下内容：
    * overview
    * 表示对象
    * 抽象函数
    * 不变式
* 过程规格在代码中每个方法前的注释中

<h3 id="道路交叉方式的输入">道路交叉方式的输入</h3>

* 与前两次作业相比，增加了道路交叉方式的输入，在输入完地图之后，会在控制台输出* "请输入道路交叉方式信息所在的文件的绝对路径" *，此时请由***控制台***输入文件的***绝对路径***。如`F:\temp\新建文本文档.txt`
* 为保留原有地图的输入方法，程序应单独增加一文件输入，定义道路交叉情况。 文件内容为 80 行字符串，每行有 80 个字符，每个字符为 0 或 1。 0 表示立体交叉， 1 表示平面交叉。理论上，两者的数量应该各占一半。 该文件与地图文件一样， ***由测试者***保证输入文件的有效性。 交叉方式与结点的邻接关系无关，并不是十字路口才能设置立体交叉，直道也允许拥有立体交叉属性。（摘自基本法）
* 程序运行开始，先输入地图所在文件，再输入道路交叉方式信息所在文件

---

> <h3 id="new">第8次作业新增内容</h3>
> 请***务必***先仔细阅读[上次内容（点击跳转）](#last)再阅读[本次作业新增内容](#new)



<h3 id="新增测试接口">新增测试接口</h3>

* `_disp.open_edge(int x,int y,String direct)`
  * 作用：打开已有的边，边的位置是与坐标(x,y)相连的上、下、左、右四条中的一个，由参数direct决定
  * x, y 的取值范围为[0,79]
  * direct 可以取的值如下：
    * `up`：表明创建的边连接坐标(x,y)与其上方的点(x-1,y)
    * `down`：表明创建的边连接坐标(x,y)与其下方的点(x+1,y)
    * `left`：表明创建的边连接坐标(x,y)与其左边的点(x,y-1)
    * `right`：表明创建的边连接坐标(x,y)与其右边的点(x,y-1)
  * 返回类型：void
  * 注意事项：
    * 支持在运行过程中动态关闭或打开一些地图上***已有的连接边***，受影响边的总数***由测试者***确保不能超过 5，任意时刻需要***由测试者***确保地图上的***所有的点都是连通***的。（摘自基本法）
    * 对上一条注意事项中***“已有的连接边”*** 的理解：即打开的边必须为地图文件信息中存在的边，也就是说，不能创建边，只能打开关闭的边。
    * 另外值得注意的是：坐标(x,y)中x代表行号，而y代表列号，因此(x,y)的上方是(x-1,y)
* `_disp.close_edge(int x,int y,String direct)`
  * 作用：关闭已有的边，边的位置是与坐标(x,y)相连的上、下、左、右四条中的一个，由参数direct决定
  * x, y 的取值范围为[0,79]
  * direct 可以取的值如下：
    * `up`：表明消除连接坐标(x,y)与其上方的点(x-1,y)的边
    * `down`：表明消除连接坐标(x,y)与其下方的点(x+1,y)的边
    * `left`：表明消除连接坐标(x,y)与其左边的点(x,y-1)的边
    * `right`：表明消除连接坐标(x,y)与其右边的点(x,y-1)的边
  * 返回类型：void
  * 注意事项：同`_disp.open_edge(int x,int y,String direct)`中注意事项

<h3 id="过程规格">过程规格</h3>

* 在每个方法前的注释中
* 包括三项内容：
  * requires: 定义了过程对输入的约束要求。
  * modifies: 过程在执行过程中对Input的修改。
  * effects: 定义了过程在所有未被Requires排除的输入下给出的执行效果。

> [继续阅读第9次新增内容（点击跳转）](#new2)

---
> <h3 id="last">第7次作业内容</h3>

<h3 id="输入">输入</h3>

* 城市地图通过文件输入，文件格式为文本文件。文件内容为 80 行字符串，
每行有 80 个字符，每个字符为 0 到 3 之间的整数。（摘自基本法）
* 文件需要***由测试者***确保地图上的所有的点都是连通的，即整个图是连通图，
但不能存在点与图外的点有连接，例如 (80,1) 不能是 2 或 3，(80,80) 只能是 0。（摘自基本法）
* 程序开始运行后，会在控制台输出 *"请输入地图数据所在的文件的绝对路径"* ，此时请在***控制台***中输入包含地图数据的文件的***绝对路径***,如`F:\temp\新建文本文档.txt`

<h3 id="本程序提供的测试接口">本程序提供的测试接口</h3>

* `_disp`为在`main`函数中创建的`disp类`的一个对象。
* 测试时，请调用`_disp`的如下方法：
  * `_disp.watcher.get_reputation(int x)`
    * 作用：获取x号出租车的信誉值
    * 返回类型为int
    * x的取值范围为[0,99]
  * `_disp.watcher.get_status(int x)`
    * 作用：获得x号出租车的运行状态
    * 返回类型为String
    * x的取值范围为[0,99]
    * 车运行的状态有如下四种：
      * `waiting`：等待服务
      * `stopped`：停止运行
      * `serving`：正在服务
      * `to-passenger`：即将服务
  * `_disp.watcher.get_x(int x)`
    * 作用：获得x号出租车在地图中所处的行号
    * 返回类型为int
    * x的取值范围为[0,99]
  * `_disp.watcher.get_y(int x)`
    * 作用：获得x号出租车在地图中所处的列号
    * 返回类型为int
    * x的取值范围为[0,99]
  * `_disp.watcher.get_time(int x)`
    * 作用：获得当前时间（当前系统时间-`_disp`这个对象被创建时的系统时间）
    * 返回类型为long
    * x的取值范围为[0,99]
  * `_disp.add_request(int x, int y, int dest_x, int dest_y)`
    * 作用：添加新的乘客请求（从(x,y)前往(dest_x,dest_y)的请求）
    * 返回类型为void
    * x, y, dest_x, dest_y 的取值范围均为[0,79]
    * 若请求无法响应，则会在控制台输出类似如下内容：
      >请求  (22,5) => (43,27) 没有车能够响应

    * 注意：由于指导书中要求请求队列容量只需不少于300，因此，一旦同时运行的请求数超过300，程序将从控制台输出提示信息。此后，虽然程序继续运行，但不对发生的错误负责
* ***注意：测试时请一定要调用_disp这个对象的测试接口，而不要创建disp类的其他对象。在main函数作用域以外测试的话需要将_disp作为参数传递过去***

<h3 id="测试">测试</h3>

* 工程中已经添加了测试代码的示例以供参考，包括`test_thread`类以及`main`函数中46~47行，建好工程直接运行就可以看到测试示例的结果。
* 建议直接修改`test_thread`类的`run`方法进行测试。（注释掉已有代码，添加新的测试代码）
* 当然，要是完全重写测试线程我也是兹词的，但要记得将`main`函数中46~47行注释掉，在相同位置启动测试线程。注意一定要像示例的测试代码那样先在`main`函数中将`_disp`作为参数传给测试线程，再在测试线程中调用`_disp`的相应方法进行测试，因为很重要所以又说了一遍。

> [继续阅读第8次新增内容（点击跳转）](#new)
